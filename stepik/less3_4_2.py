'''
На прошлой неделе мы сжимали строки, используя кодирование повторов.
Теперь нашей задачей будет восстановление исходной строки обратно.

Напишите программу, которая считывает из файла строку, соответствующую тексту,
сжатому с помощью кодирования повторов, и производит обратную операцию, получая исходный текст.

Запишите полученный текст в файл и прикрепите его, как ответ на это задание.

В исходном тексте не встречаются цифры, так что код однозначно интерпретируем.

Примечание. Это первое задание типа Dataset Quiz. В таких заданиях после нажатия "Start Quiz"
у вас появляется ссылка "download your dataset". Используйте эту ссылку для того
, чтобы загрузить файл со входными данными к себе на компьютер.
Запустите вашу программу, используя этот файл в качестве входных данных.
Выходной файл, который при этом у вас получится, надо отправить в качестве ответа на эту задачу. 
----------------------------------
Sample Input:
a3b4c2e10b1
Sample Output:
aaabbbbcceeeeeeeeeeb
----------------------------------
У вас есть неограниченное число попыток.
Время одной попытки: 5 mins

'''
##----------------------------------------------------------------------------------

def decode_string(ln,d):
    num=''
    s=''
    letter=ln[0]
    for x in ln:
        if x.isalpha():
            if num !='':
                s+=letter*int(num)    
                num=''
                letter=x
        else:
            num+=x
    s+=letter*int(num)
    print (s)        
    return s

#main            
fl=input('Input file name: ')
d={}
print (fl)

if fl not in ['n','N']:
    with open(fl,'r') as inpt:
        for ln in inpt:
            s=decode_string(ln,d)
    with open('3-4-2result.txt','w') as outp:
        outp.write(s)
        print()
        print('file created')
else:
    ln=input('Test string: ')
    decode_string(ln,d)


'''
красивые решения
v1
with open('dataset_3363_2.txt', 'r') as f:
    s = f.readline().strip()
i = 0
while i < len(s):
    j = i + 1
    while j < len(s) and s[j].isdigit():
        j += 1
    print(s[i] * int(s[i+1:j]), end='')
    i = j

Первый символ - гарантированно буква.
Перебираем все последующие, пока они цифровые или пока не достигнут конец строки.
После внутреннего цикла j либо указывает на следующую букву, либо на конец строки. В обоих случаях между s[i] и s[j] - цифры, составляющие нужное нам число повторов символа s[i].
Печатаем символ нужное число раз, присваиваем i индекс следующей буквы для новой итерации цикла.

v2
with open ('dataset_3363_2.txt','r') as inf:
    s1 = inf.readline().strip()
n=0
k=''
alpha=[]
numbers=[]
for i in range(len(s1)):             #список только с буквами
    if s1[i].isalpha():
        alpha.append(s1[i])
for i in range (len(s1)):             #список только с числами
    if s1[i].isdigit():
        n+=1
        if i == len(s1)-1:
            numbers.append(s1[len(s1)-n:i+1])
    if s1[i].isalpha() and n!=0:
        numbers.append(s1[i-n:i])
        n=0
for i in range(len(alpha)):            #умножаем букву из первого списка на число из второго списка
    k=k+alpha[i]*int(numbers[i])          #складываем все буквы в str переменную
with open ('outfile.txt','w') as ouf:
    ouf.write(k)
'''
